# CODE GENERATION

## Overview

Type-safe asset references eliminate runtime errors from typos in asset paths. This document explains how to generate Dart code from your assets folder.

---

## Why Code Generation?

### The Problem

**Without code generation:**
```dart
// Runtime error if path is wrong
Image.asset('assets/images/logo.png');

// No autocomplete
Image.asset('assets/images/');  // What files exist?

// Typos only caught at runtime
Image.asset('assets/images/loggo.png');  // Crashes!
```

**With code generation:**
```dart
// Compile-time safety
Image.asset(Assets.logo);

// Full autocomplete
Image.asset(Assets.);  // IDE shows: logo, background, icon...

// Typos caught immediately
Image.asset(Assets.loggo);  // Compile error!
```

---

## Generated Code Structure

### Basic Structure
```dart
// lib/gen/assets.dart
// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by dart_assets on 2025-02-14 10:30:00

// ignore_for_file: constant_identifier_names
// ignore_for_file: non_constant_identifier_names

/// Auto-generated asset references
class Assets {
  Assets._();
  
  // Images
  static const String logo = 'assets/images/logo.png';
  static const String background = 'assets/images/background.jpg';
  static const String iconHome = 'assets/icons/home.svg';
  
  // Fonts
  static const String robotoRegular = 'assets/fonts/Roboto-Regular.ttf';
  static const String robotoBold = 'assets/fonts/Roboto-Bold.ttf';
  
  // All assets
  static const List<String> all = [
    logo,
    background,
    iconHome,
    robotoRegular,
    robotoBold,
  ];
}
```

### Advanced Structure (with Metadata)
```dart
// lib/gen/assets.dart
import 'dart:ui' show Size;

class Assets {
  Assets._();
  
  // Images
  static const String logo = 'assets/images/logo.png';
  static const AssetMetadata logoMeta = AssetMetadata(
    path: 'assets/images/logo.png',
    width: 512,
    height: 512,
    fileSize: 45234,
    format: 'png',
  );
  
  static const String background = 'assets/images/background.jpg';
  static const AssetMetadata backgroundMeta = AssetMetadata(
    path: 'assets/images/background.jpg',
    width: 1920,
    height: 1080,
    fileSize: 234567,
    format: 'jpeg',
  );
  
  // Grouped by directory
  static const images = _Images();
  static const fonts = _Fonts();
}

class _Images {
  const _Images();
  
  String get logo => Assets.logo;
  String get background => Assets.background;
}

class _Fonts {
  const _Fonts();
  
  String get robotoRegular => Assets.robotoRegular;
  String get robotoBold => Assets.robotoBold;
}

/// Metadata for asset files
class AssetMetadata {
  final String path;
  final int width;
  final int height;
  final int fileSize;
  final String format;
  
  const AssetMetadata({
    required this.path,
    required this.width,
    required this.height,
    required this.fileSize,
    required this.format,
  });
}
```

---

## Implementation

### 1. Asset Scanner
```dart
// lib/src/generator/asset_scanner.dart
import 'dart:io';
import 'package:path/path.dart' as p;

class AssetScanner {
  final Directory projectRoot;
  
  AssetScanner({required this.projectRoot});
  
  /// Scan assets directory and return all asset files
  Future<List<AssetInfo>> scan() async {
    final assetsDir = Directory('${projectRoot.path}/assets');
    
    if (!assetsDir.existsSync()) {
      throw AssetDirectoryNotFoundError(assetsDir.path);
    }
    
    final assets = <AssetInfo>[];
    
    // Recursively scan directory
    await for (final entity in assetsDir.list(recursive: true)) {
      if (entity is File && _isSupportedAsset(entity.path)) {
        final info = await _createAssetInfo(entity);
        assets.add(info);
      }
    }
    
    // Sort by path for consistent output
    assets.sort((a, b) => a.path.compareTo(b.path));
    
    return assets;
  }
  
  bool _isSupportedAsset(String path) {
    const supportedExtensions = [
      '.png', '.jpg', '.jpeg', '.gif', '.webp', '.svg', '.bmp',
      '.ttf', '.otf', '.woff', '.woff2',
      '.mp4', '.mov', '.avi',
      '.json', '.xml',
    ];
    
    return supportedExtensions.any((ext) => path.toLowerCase().endsWith(ext));
  }
  
  Future<AssetInfo> _createAssetInfo(File file) async {
    final relativePath = p.relative(file.path, from: projectRoot.path);
    final name = p.basenameWithoutExtension(file.path);
    final extension = p.extension(file.path).substring(1); // Remove dot
    final stat = await file.stat();
    
    return AssetInfo(
      path: relativePath,
      name: name,
      extension: extension,
      fileSize: stat.size,
      file: file,
    );
  }
}

/// Information about an asset file
class AssetInfo {
  final String path;        // Relative path from project root
  final String name;        // Filename without extension
  final String extension;   // File extension
  final int fileSize;       // Size in bytes
  final File file;          // File reference
  
  AssetInfo({
    required this.path,
    required this.name,
    required this.extension,
    required this.fileSize,
    required this.file,
  });
  
  bool get isImage => const [
    'png', 'jpg', 'jpeg', 'gif', 'webp', 'svg', 'bmp'
  ].contains(extension.toLowerCase());
  
  bool get isFont => const [
    'ttf', 'otf', 'woff', 'woff2'
  ].contains(extension.toLowerCase());
  
  bool get isVideo => const [
    'mp4', 'mov', 'avi', 'mkv'
  ].contains(extension.toLowerCase());
}
```

---

### 2. Metadata Extractor
```dart
// lib/src/generator/metadata_extractor.dart
import 'dart:io';
import 'package:image/image.dart' as img;

class MetadataExtractor {
  /// Extract metadata from image file
  Future<ImageMetadata?> extractImageMetadata(File file) async {
    try {
      final bytes = await file.readAsBytes();
      final image = img.decodeImage(bytes);
      
      if (image == null) {
        return null;
      }
      
      return ImageMetadata(
        width: image.width,
        height: image.height,
        format: _detectFormat(file.path),
      );
    } catch (e) {
      // If we can't read the image, return null
      return null;
    }
  }
  
  String _detectFormat(String path) {
    final extension = path.split('.').last.toLowerCase();
    
    switch (extension) {
      case 'jpg':
      case 'jpeg':
        return 'jpeg';
      case 'png':
        return 'png';
      case 'gif':
        return 'gif';
      case 'webp':
        return 'webp';
      case 'bmp':
        return 'bmp';
      case 'svg':
        return 'svg';
      default:
        return extension;
    }
  }
}

class ImageMetadata {
  final int width;
  final int height;
  final String format;
  
  ImageMetadata({
    required this.width,
    required this.height,
    required this.format,
  });
}
```

---

### 3. Naming Converter
```dart
// lib/src/generator/naming_converter.dart

class NamingConverter {
  /// Convert file name to valid Dart identifier
  static String toValidIdentifier(String name) {
    // Remove extension
    name = name.split('.').first;
    
    // Replace invalid characters with underscores
    name = name.replaceAll(RegExp(r'[^a-zA-Z0-9_]'), '_');
    
    // Ensure doesn't start with number
    if (RegExp(r'^\d').hasMatch(name)) {
      name = '_$name';
    }
    
    // Convert to camelCase
    return _toCamelCase(name);
  }
  
  /// Convert to camelCase
  static String _toCamelCase(String input) {
    // Split by underscores, hyphens, or spaces
    final parts = input.split(RegExp(r'[-_\s]+'));
    
    if (parts.isEmpty) return input;
    
    // First part lowercase
    final first = parts.first.toLowerCase();
    
    // Rest with capital first letter
    final rest = parts.skip(1).map((part) {
      if (part.isEmpty) return '';
      return part[0].toUpperCase() + part.substring(1).toLowerCase();
    });
    
    return [first, ...rest].join();
  }
  
  /// Convert to PascalCase
  static String toPascalCase(String input) {
    final camelCase = _toCamelCase(input);
    if (camelCase.isEmpty) return camelCase;
    
    return camelCase[0].toUpperCase() + camelCase.substring(1);
  }
}

// Examples:
// "logo.png"           → "logo"
// "app-icon.svg"       → "appIcon"
// "user_profile.jpg"   → "userProfile"
// "2x-image.png"       → "_2xImage"
// "my image file.png"  → "myImageFile"
```

---

### 4. Code Generator
```dart
// lib/src/generator/code_generator.dart
import 'dart:io';
import 'package:dart_style/dart_style.dart';

class CodeGenerator {
  final Directory projectRoot;
  final AssetScanner _scanner;
  final MetadataExtractor _metadataExtractor;
  
  CodeGenerator({required this.projectRoot})
      : _scanner = AssetScanner(projectRoot: projectRoot),
        _metadataExtractor = MetadataExtractor();
  
  /// Generate assets.dart file
  Future<void> generate() async {
    // Scan assets
    final assets = await _scanner.scan();
    
    if (assets.isEmpty) {
      print('⚠️  No assets found');
      return;
    }
    
    // Generate code
    final code = await _generateCode(assets);
    
    // Format code
    final formatter = DartFormatter();
    final formatted = formatter.format(code);
    
    // Write to file
    final outputFile = File('${projectRoot.path}/lib/gen/assets.dart');
    await outputFile.parent.create(recursive: true);
    await outputFile.writeAsString(formatted);
    
    print('Generated ${outputFile.path}');
    print('   ${assets.length} assets');
  }
  
  Future<String> _generateCode(List<AssetInfo> assets) async {
    final buffer = StringBuffer();
    
    // Header
    _writeHeader(buffer);
    
    // Start class
    buffer.writeln('class Assets {');
    buffer.writeln('  Assets._();');
    buffer.writeln();
    
    // Group assets by type
    final images = assets.where((a) => a.isImage).toList();
    final fonts = assets.where((a) => a.isFont).toList();
    final videos = assets.where((a) => a.isVideo).toList();
    final other = assets.where((a) => 
      !a.isImage && !a.isFont && !a.isVideo
    ).toList();
    
    // Generate constants
    if (images.isNotEmpty) {
      buffer.writeln('  // Images');
      await _writeAssets(buffer, images);
      buffer.writeln();
    }
    
    if (fonts.isNotEmpty) {
      buffer.writeln('  // Fonts');
      await _writeAssets(buffer, fonts);
      buffer.writeln();
    }
    
    if (videos.isNotEmpty) {
      buffer.writeln('  // Videos');
      await _writeAssets(buffer, videos);
      buffer.writeln();
    }
    
    if (other.isNotEmpty) {
      buffer.writeln('  // Other');
      await _writeAssets(buffer, other);
      buffer.writeln();
    }
    
    // All assets list
    _writeAllAssetsList(buffer, assets);
    
    // Close class
    buffer.writeln('}');
    
    return buffer.toString();
  }
  
  void _writeHeader(StringBuffer buffer) {
    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// Generated by dart_assets on ${DateTime.now()}');
    buffer.writeln();
    buffer.writeln('// ignore_for_file: constant_identifier_names');
    buffer.writeln('// ignore_for_file: non_constant_identifier_names');
    buffer.writeln();
  }
  
  Future<void> _writeAssets(
    StringBuffer buffer,
    List<AssetInfo> assets,
  ) async {
    // Track used names to avoid duplicates
    final usedNames = <String>{};
    
    for (final asset in assets) {
      final name = _generateUniqueName(asset.name, usedNames);
      usedNames.add(name);
      
      // Write constant
      buffer.writeln('  static const String $name = \'${asset.path}\';');
      
      // Write metadata if image
      if (asset.isImage) {
        final metadata = await _metadataExtractor
            .extractImageMetadata(asset.file);
        
        if (metadata != null) {
          _writeImageMetadata(buffer, name, asset, metadata);
        }
      }
    }
  }
  
  void _writeImageMetadata(
    StringBuffer buffer,
    String name,
    AssetInfo asset,
    ImageMetadata metadata,
  ) {
    buffer.writeln('  static const ${name}Meta = AssetMetadata(');
    buffer.writeln('    path: \'${asset.path}\',');
    buffer.writeln('    width: ${metadata.width},');
    buffer.writeln('    height: ${metadata.height},');
    buffer.writeln('    fileSize: ${asset.fileSize},');
    buffer.writeln('    format: \'${metadata.format}\',');
    buffer.writeln('  );');
  }
  
  void _writeAllAssetsList(StringBuffer buffer, List<AssetInfo> assets) {
    buffer.writeln('  /// All asset paths');
    buffer.writeln('  static const List<String> all = [');
    
    final usedNames = <String>{};
    for (final asset in assets) {
      final name = _generateUniqueName(asset.name, usedNames);
      usedNames.add(name);
      buffer.writeln('    $name,');
    }
    
    buffer.writeln('  ];');
  }
  
  String _generateUniqueName(String baseName, Set<String> usedNames) {
    var name = NamingConverter.toValidIdentifier(baseName);
    
    // If name is taken, append number
    if (usedNames.contains(name)) {
      var counter = 2;
      while (usedNames.contains('$name$counter')) {
        counter++;
      }
      name = '$name$counter';
    }
    
    return name;
  }
}
```

---

### 5. Adding Metadata Class
```dart
Future<String> _generateCode(List<AssetInfo> assets) async {
  final buffer = StringBuffer();
  
  _writeHeader(buffer);
  
  // Add metadata class
  _writeMetadataClass(buffer);
  buffer.writeln();
  
  // Rest of generation...
  buffer.writeln('class Assets {');
  // ...
}

void _writeMetadataClass(StringBuffer buffer) {
  buffer.writeln('/// Metadata for asset files');
  buffer.writeln('class AssetMetadata {');
  buffer.writeln('  final String path;');
  buffer.writeln('  final int width;');
  buffer.writeln('  final int height;');
  buffer.writeln('  final int fileSize;');
  buffer.writeln('  final String format;');
  buffer.writeln();
  buffer.writeln('  const AssetMetadata({');
  buffer.writeln('    required this.path,');
  buffer.writeln('    required this.width,');
  buffer.writeln('    required this.height,');
  buffer.writeln('    required this.fileSize,');
  buffer.writeln('    required this.format,');
  buffer.writeln('  });');
  buffer.writeln('}');
}
```

---

## Grouping Strategies

### Strategy 1: Flat (Simple)

**Best for:** Small projects (<50 assets)
```dart
class Assets {
  static const String logo = 'assets/images/logo.png';
  static const String icon = 'assets/icons/home.svg';
  static const String roboto = 'assets/fonts/Roboto.ttf';
}

// Usage:
Image.asset(Assets.logo);
```

---

### Strategy 2: Grouped by Type

**Best for:** Medium projects (50-200 assets)
```dart
class Assets {
  Assets._();
  
  static const images = _Images();
  static const icons = _Icons();
  static const fonts = _Fonts();
}

class _Images {
  const _Images();
  
  String get logo => 'assets/images/logo.png';
  String get background => 'assets/images/background.jpg';
}

class _Icons {
  const _Icons();
  
  String get home => 'assets/icons/home.svg';
  String get settings => 'assets/icons/settings.svg';
}

// Usage:
Image.asset(Assets.images.logo);
Icon(Assets.icons.home);
```

**Implementation:**
```dart
Future<void> _writeGroupedAssets(
  StringBuffer buffer,
  List<AssetInfo> assets,
) async {
  // Group by directory
  final groups = <String, List<AssetInfo>>{};
  
  for (final asset in assets) {
    final dir = _getDirectory(asset.path);
    groups.putIfAbsent(dir, () => []).add(asset);
  }
  
  // Write main class
  buffer.writeln('class Assets {');
  buffer.writeln('  Assets._();');
  buffer.writeln();
  
  // Write group accessors
  for (final dir in groups.keys) {
    final className = '_${NamingConverter.toPascalCase(dir)}';
    final fieldName = NamingConverter.toValidIdentifier(dir);
    
    buffer.writeln('  static const $fieldName = $className();');
  }
  buffer.writeln('}');
  buffer.writeln();
  
  // Write group classes
  for (final entry in groups.entries) {
    await _writeGroupClass(buffer, entry.key, entry.value);
  }
}

String _getDirectory(String path) {
  // "assets/images/logo.png" → "images"
  final parts = path.split('/');
  if (parts.length > 2) {
    return parts[1];
  }
  return 'other';
}

Future<void> _writeGroupClass(
  StringBuffer buffer,
  String groupName,
  List<AssetInfo> assets,
) async {
  final className = '_${NamingConverter.toPascalCase(groupName)}';
  
  buffer.writeln('class $className {');
  buffer.writeln('  const $className();');
  buffer.writeln();
  
  for (final asset in assets) {
    final name = NamingConverter.toValidIdentifier(asset.name);
    buffer.writeln('  String get $name => \'${asset.path}\';');
  }
  
  buffer.writeln('}');
  buffer.writeln();
}
```

---

### Strategy 3: Hierarchical (Advanced)

**Best for:** Large projects (>200 assets)
```dart
class Assets {
  static const images = _Images();
  static const icons = _Icons();
}

class _Images {
  const _Images();
  
  // Subgroups
  final logos = _ImageLogos();
  final backgrounds = _ImageBackgrounds();
  final avatars = _ImageAvatars();
}

class _ImageLogos {
  const _ImageLogos();
  
  String get main => 'assets/images/logos/main.png';
  String get dark => 'assets/images/logos/dark.png';
}

// Usage:
Image.asset(Assets.images.logos.main);
```

---

## Incremental Generation

**Problem:** Regenerating entire file on every change is slow for large projects.

**Solution:** Track changes and only update affected parts.
```dart
class IncrementalGenerator {
  final File outputFile;
  final Map<String, String> _cache = {};
  
  Future<void> generateIncremental(List<AssetInfo> assets) async {
    String? existingContent;
    
    if (outputFile.existsSync()) {
      existingContent = await outputFile.readAsString();
      _parseExistingConstants(existingContent);
    }
    
    // Generate only changed assets
    final changes = _detectChanges(assets);
    
    if (changes.isEmpty && existingContent != null) {
      print('✅ No changes detected');
      return;
    }
    
    // Full regeneration
    await _generateFull(assets);
  }
  
  void _parseExistingConstants(String content) {
    // Extract existing constants
    final regex = RegExp(r'static const String (\w+) = \'([^\']+)\';');
    final matches = regex.allMatches(content);
    
    for (final match in matches) {
      final name = match.group(1)!;
      final path = match.group(2)!;
      _cache[name] = path;
    }
  }
  
  List<String> _detectChanges(List<AssetInfo> assets) {
    final changes = <String>[];
    
    for (final asset in assets) {
      final name = NamingConverter.toValidIdentifier(asset.name);
      final existingPath = _cache[name];
      
      if (existingPath != asset.path) {
        changes.add(asset.path);
      }
    }
    
    return changes;
  }
}
```

---

## Code Formatting

### Using dart_style
```dart
import 'package:dart_style/dart_style.dart';

Future<void> generate() async {
  final code = await _generateCode(assets);
  
  // Format
  final formatter = DartFormatter(
    pageWidth: 80,
    fixes: StyleFix.all,
  );
  
  try {
    final formatted = formatter.format(code);
    await outputFile.writeAsString(formatted);
  } on FormatterException catch (e) {
    print('⚠️  Code formatting failed: $e');
    // Write unformatted code anyway
    await outputFile.writeAsString(code);
  }
}
```

---

## Testing Generated Code

### Verify Generated Code Compiles
```dart
// test/integration/code_generation_test.dart
import 'dart:io';
import 'package:test/test.dart';

void main() {
  group('Code Generation', () {
    late Directory testProject;
    
    setUp(() {
      testProject = Directory.systemTemp.createTempSync('test_');
      
      // Create test assets
      final assetsDir = Directory('${testProject.path}/assets/images')
        ..createSync(recursive: true);
      
      File('${assetsDir.path}/logo.png').writeAsBytesSync([]);
      File('${assetsDir.path}/icon.svg').writeAsBytesSync([]);
    });
    
    tearDown() {
      testProject.deleteSync(recursive: true);
    });
    
    test('should generate valid Dart code', () async {
      final generator = CodeGenerator(projectRoot: testProject);
      await generator.generate();
      
      final outputFile = File('${testProject.path}/lib/gen/assets.dart');
      
      expect(outputFile.existsSync(), true);
      
      final content = await outputFile.readAsString();
      
      // Check structure
      expect(content, contains('class Assets'));
      expect(content, contains('static const String logo'));
      expect(content, contains('assets/images/logo.png'));
    });
    
    test('should compile generated code', () async {
      final generator = CodeGenerator(projectRoot: testProject);
      await generator.generate();
      
      // Try to analyze generated code
      final result = await Process.run(
        'dart',
        ['analyze', '${testProject.path}/lib/gen/assets.dart'],
      );
      
      expect(result.exitCode, 0, reason: 'Generated code should analyze without errors');
    });
  });
}
```

---

## Best Practices

### 1. Ignore Generated Files in Git

**.gitignore:**
```
# Generated files
lib/gen/
*.g.dart
```

**Why:** Generated files should be created during build, not committed.

### 2. Add Build Instructions

**README.md:**
```markdown
## Building

After cloning, generate asset files:

\`\`\`bash
dart_assets gen
\`\`\`

Or use watch mode during development:

\`\`\`bash
dart_assets watch
\`\`\`
```

### 3. Handle Name Conflicts
```dart
String _generateUniqueName(String baseName, Set<String> usedNames) {
  var name = NamingConverter.toValidIdentifier(baseName);
  
  // Check for Dart keywords
  const keywords = [
    'assert', 'break', 'case', 'catch', 'class', 'const',
    'continue', 'default', 'do', 'else', 'enum', 'extends',
    'false', 'final', 'finally', 'for', 'if', 'in', 'is',
    'new', 'null', 'rethrow', 'return', 'super', 'switch',
    'this', 'throw', 'true', 'try', 'var', 'void', 'while',
    'with',
  ];
  
  if (keywords.contains(name)) {
    name = '${name}Asset'; // "class.png" → "classAsset"
  }
  
  // Handle duplicates
  if (usedNames.contains(name)) {
    var counter = 2;
    while (usedNames.contains('$name$counter')) {
      counter++;
    }
    name = '$name$counter';
  }
  
  return name;
}
```

### 4. Add Documentation
```dart
void _writeDocumentation(StringBuffer buffer, AssetInfo asset) {
  buffer.writeln('  /// ${asset.name}');
  buffer.writeln('  /// Path: ${asset.path}');
  
  if (asset.isImage) {
    buffer.writeln('  /// Size: ${_formatFileSize(asset.fileSize)}');
  }
  
  buffer.writeln('  static const String ${asset.name} = \'${asset.path}\';');
}

String _formatFileSize(int bytes) {
  if (bytes < 1024) return '$bytes B';
  if (bytes < 1024 * 1024) return '${(bytes / 1024).toStringAsFixed(1)} KB';
  return '${(bytes / (1024 * 1024)).toStringAsFixed(1)} MB';
}
```

**Output:**
```dart
/// logo
/// Path: assets/images/logo.png
/// Size: 45.2 KB
static const String logo = 'assets/images/logo.png';
```

---

## Common Issues

### Issue 1: Duplicate Names

**Problem:**
```
assets/images/logo.png
assets/icons/logo.svg
```

Both would generate `Assets.logo`!

**Solution:**
```dart
// Option 1: Include directory in name
static const String imagesLogo = 'assets/images/logo.png';
static const String iconsLogo = 'assets/icons/logo.svg';

// Option 2: Number duplicates
static const String logo = 'assets/images/logo.png';
static const String logo2 = 'assets/icons/logo.svg';
```

### Issue 2: Invalid Dart Identifiers

**Problem:**
```
2x-logo.png     → "2xLogo" (starts with number)
my-logo!.png    → "myLogo!" (invalid character)
class.png       → "class" (keyword)
```

**Solution:** Sanitize in `NamingConverter.toValidIdentifier()`

### Issue 3: Very Long Names

**Problem:**
```
very_long_descriptive_asset_name_for_marketing_campaign_2024.png
```

**Solution:**
```dart
String _truncateName(String name, {int maxLength = 50}) {
  if (name.length <= maxLength) return name;
  
  // Keep first 40 chars + hash of rest
  final hash = name.hashCode.abs().toString().substring(0, 6);
  return '${name.substring(0, 40)}_$hash';
}
```